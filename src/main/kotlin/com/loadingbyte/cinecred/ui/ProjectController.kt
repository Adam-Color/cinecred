package com.loadingbyte.cinecred.ui

import com.loadingbyte.cinecred.common.Picture
import com.loadingbyte.cinecred.common.Severity.ERROR
import com.loadingbyte.cinecred.drawer.draw
import com.loadingbyte.cinecred.project.*
import com.loadingbyte.cinecred.projectio.*
import com.loadingbyte.cinecred.ui.helper.BUNDLED_FAMILIES
import com.loadingbyte.cinecred.ui.helper.FontFamilies
import com.loadingbyte.cinecred.ui.helper.JobSlot
import com.loadingbyte.cinecred.ui.helper.SYSTEM_FAMILIES
import com.loadingbyte.cinecred.ui.styling.EditStylingDialog
import kotlinx.collections.immutable.toImmutableList
import kotlinx.collections.immutable.toImmutableMap
import java.awt.Font
import java.awt.GraphicsConfiguration
import java.io.IOException
import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.StandardWatchEventKinds.ENTRY_DELETE
import java.nio.file.WatchEvent
import java.util.*
import java.util.concurrent.ConcurrentHashMap
import javax.swing.JPanel
import javax.swing.SwingUtilities


class ProjectController(val projectDir: Path, val openOnScreen: GraphicsConfiguration) {

    val projectName: String = projectDir.fileName.toString()

    val stylingHistory: StylingHistory

    val projectFrame = ProjectFrame(this)
    val editStylingDialog = EditStylingDialog(this)

    private val stylingFile = projectDir.resolve(STYLING_FILE_NAME)
    private var creditsFile: Path? = null

    private var creditsSpreadsheet: Spreadsheet = emptyList()
    private val fonts = ConcurrentHashMap<Path, List<Font>>()
    private val pictureLoaders = ConcurrentHashMap<Path, Lazy<Picture?>>()

    // The state that is relevant for pushStateIntoUI().
    private var creditsFileLocatingLog: List<ParserMsg> = emptyList()
    private var creditsFileLoadingLog: List<ParserMsg> = emptyList()
    private var creditsFileReadingLog: List<ParserMsg> = emptyList()
    private var stylingError = false
    private var project: Project? = null
    private var drawnPages: List<DrawnPage> = emptyList()

    private val readCreditsAndRedrawJobSlot = JobSlot()

    private var isEditTabActive = true
    private var isEditStylingDialogVisible = true

    init {
        projectFrame.isVisible = true
        editStylingDialog.isVisible = true

        makeProjectHintTrack(this).playIfPending()

        // Load the initially present auxiliary files (project fonts and pictures).
        for (projectFile in Files.walk(projectDir))
            tryReloadAuxFile(projectFile)

        // Load the initial state of the styling from disk.
        stylingHistory = StylingHistory(readStyling(stylingFile))

        // Try to find a credits file.
        tryLocateCreditsFile()
        // If present, load the initial credits spreadsheet from disk.
        tryReloadCreditsFile()
        // If present, read and draw the credits.
        tryReadCreditsAndRedraw()

        // Watch for future changes in the new project dir.
        RecursiveFileWatcher.watch(projectDir) { file: Path, kind: WatchEvent.Kind<*> ->
            val creditsFile = this.creditsFile  // capture
            when {
                hasCreditsFileName(file) -> {
                    tryLocateCreditsFile()
                    val newCreditsFile = this.creditsFile
                    if (file == newCreditsFile || newCreditsFile == null ||
                        (creditsFile != null && !safeIsSameFile(creditsFile, newCreditsFile))
                    ) {
                        tryReloadCreditsFile()
                        tryReadCreditsAndRedraw()
                    } else
                        pushStateIntoUI()  // Update the log entry regarding multiple credits files.
                }
                kind == ENTRY_DELETE ->
                    SwingUtilities.invokeLater { if (tryRemoveAuxFile(file)) tryReadCreditsAndRedraw() }
                else ->
                    SwingUtilities.invokeLater { if (tryReloadAuxFile(file)) tryReadCreditsAndRedraw() }
            }
        }
    }

    private fun pushStateIntoUI() {
        val log = creditsFileLocatingLog + creditsFileLoadingLog + creditsFileReadingLog
        projectFrame.panel.editPanel.updateProject(project, drawnPages, stylingError, log)
        editStylingDialog.panel.updateProject(project)
        projectFrame.panel.videoPanel.updateProject(project, drawnPages)
        projectFrame.panel.deliverPanel.configurationForm.updateProject(project, drawnPages)
    }

    private fun tryReloadAuxFile(file: Path): Boolean {
        // If the file has been generated by a render job, don't reload the project. Otherwise, generating image
        // sequences would be very expensive because we would constantly reload the project. Note that we do not
        // only consider the current render job, but all render jobs in the render job list. This ensures that even
        // the last file generated by a render job doesn't reload the project even when the render job has already
        // been marked as complete by the time the OS notifies us about the newly generated file.
        if (projectFrame.panel.deliverPanel.renderQueuePanel.renderJobs.any { it.generatesFile(file) })
            return false

        val newFonts = tryReadFonts(file)
        if (newFonts.isNotEmpty()) {
            fonts[file] = newFonts
            editStylingDialog.panel.updateProjectFontFamilies(FontFamilies(fonts.values.flatten()))
            return true
        }

        tryReadPictureLoader(file)?.let { pictureLoader ->
            pictureLoaders[file] = pictureLoader
            return true
        }

        return false
    }

    private fun tryRemoveAuxFile(file: Path): Boolean {
        if (fonts.remove(file) != null) {
            editStylingDialog.panel.updateProjectFontFamilies(FontFamilies(fonts.values.flatten()))
            return true
        }
        if (pictureLoaders.remove(file) != null)
            return true
        return false
    }

    private fun tryLocateCreditsFile() {
        val (file, log) = locateCreditsFile(projectDir)
        creditsFile = file
        creditsFileLocatingLog = log
    }

    private fun tryReloadCreditsFile() {
        creditsSpreadsheet = emptyList()
        creditsFileLoadingLog = emptyList()

        creditsFile?.let { creditsFile ->
            try {
                val (spreadsheet, log) = loadCreditsFile(creditsFile)
                creditsSpreadsheet = spreadsheet
                creditsFileLoadingLog = log
            } catch (_: IOException) {
                // An IO exception can occur if the credits file has disappeared in the meantime.
                // If that happens, the file watcher will quickly trigger a locating and then a reloading call.
            }
        }
    }

    private fun tryReadCreditsAndRedraw() {
        // Capture these variables in the state they are in when the function is called.
        val styling = stylingHistory.current
        val creditsSpreadsheet = this.creditsSpreadsheet

        // Reset these variables. We will set some of them in the following code, depending on which problems occur.
        creditsFileReadingLog = emptyList()
        stylingError = false
        project = null
        drawnPages = emptyList()

        // If the credits file could not be located or loaded, abort and notify the UI about the error.
        if (creditsFileLocatingLog.any { it.severity == ERROR } || creditsFileLoadingLog.any { it.severity == ERROR })
            return pushStateIntoUI()

        // Execute the reading and drawing in another thread to not block the UI thread.
        readCreditsAndRedrawJobSlot.submit {
            // Verify the styling in the extra thread because that is not entirely cheap.
            // If the styling is erroneous, abort and notify the UI about the error.
            if (verifyStylingConstraints(styling).any { it.severity == ERROR })
                return@submit SwingUtilities.invokeLater { stylingError = true; pushStateIntoUI() }

            // We only now build these maps because it is expensive to build them and we don't want to do it
            // each time the function is called, but only when the issued reload & redraw actually gets through
            // (which is quite a lot less because the function is often called multiple times in rapid succession).
            val fontsByName = fonts.values.flatten().associateBy { font -> font.getFontName(Locale.ROOT) }
            val pictureLoadersByRelPath = pictureLoaders.mapKeys { (path, _) -> projectDir.relativize(path) }

            val (pages, runtimeGroups, log) = readCredits(creditsSpreadsheet, styling, pictureLoadersByRelPath)

            // If the credits spreadsheet could not be read and parsed, abort and notify the UI about the error.
            if (log.any { it.severity == ERROR })
                return@submit SwingUtilities.invokeLater { creditsFileReadingLog = log; pushStateIntoUI() }

            val project = Project(
                styling, fontsByName.toImmutableMap(), pages.toImmutableList(), runtimeGroups.toImmutableList()
            )
            val drawnPages = draw(project)

            SwingUtilities.invokeLater {
                creditsFileReadingLog = log
                this.project = project
                this.drawnPages = drawnPages
                pushStateIntoUI()
            }
        }
    }

    fun tryCloseProject(force: Boolean = false): Boolean {
        if (force) {
            projectFrame.panel.editPanel.onTryCloseProject()
            projectFrame.panel.deliverPanel.renderQueuePanel.onTryCloseProject()
        } else if (
            !projectFrame.panel.editPanel.onTryCloseProject() ||
            !projectFrame.panel.deliverPanel.renderQueuePanel.onTryCloseProject()
        )
            return false

        OpenController.onCloseProject(this)

        projectFrame.dispose()
        editStylingDialog.dispose()
        // Cancel the previous project dir change watching order.
        RecursiveFileWatcher.unwatch(projectDir)

        return true
    }

    fun onChangeTab(leftPanel: JPanel, enteredPanel: JPanel) {
        val enteredEdit = enteredPanel is EditPanel
        isEditTabActive = enteredEdit
        editStylingDialog.isVisible = enteredEdit && isEditStylingDialogVisible
        if (leftPanel is VideoPanel)
            projectFrame.panel.videoPanel.onLeaveTab()
    }

    fun setEditStylingDialogVisible(isVisible: Boolean) {
        isEditStylingDialogVisible = isVisible
        editStylingDialog.isVisible = isEditTabActive && isVisible
        projectFrame.panel.editPanel.onSetEditStylingDialogVisible(isVisible)
    }

    /**
     * Note: In contrast to most methods in this class, this method has no side-effects.
     */
    fun verifyStylingConstraints(styling: Styling) =
        verifyConstraints(styling, isFontName = { fontName ->
            fonts.values.any { it.any { font -> fontName == font.getFontName(Locale.ROOT) } } ||
                    BUNDLED_FAMILIES.getFamily(fontName) != null ||
                    SYSTEM_FAMILIES.getFamily(fontName) != null
        })


    companion object {

        const val STYLING_FILE_NAME = "Styling.toml"

        private fun safeIsSameFile(p1: Path, p2: Path) =
            try {
                Files.isSameFile(p1, p2)
            } catch (_: IOException) {
                false
            }

    }


    inner class StylingHistory(private var saved: Styling) {

        private val history = mutableListOf(saved)
        private var currentIdx = 0

        val current: Styling
            get() = history[currentIdx]

        private var lastEditedSetting: StyleSetting<*, *>? = null
        private var lastEditedMillis = 0L

        init {
            projectFrame.panel.editPanel.onStylingChange(isUnsaved = false, isUndoable = false, isRedoable = false)
            editStylingDialog.panel.setStyling(saved)
        }

        fun editedAndRedraw(new: Styling, edited: StyleSetting<*, *>?) {
            if (new != current) {
                // If the user edits the styling after having undoed some steps, those steps are now dropped.
                while (history.lastIndex != currentIdx)
                    history.removeAt(history.lastIndex)
                // If the user edits the same setting multiple times in quick succession, do not memorize a new
                // state for each edit, but instead overwrite the last state after each edit. This for example avoids
                // a new state being created for each increment of a spinner.
                val currMillis = System.currentTimeMillis()
                val rapidSucc = edited != null && lastEditedSetting == edited && currMillis - lastEditedMillis < 1000
                lastEditedSetting = edited
                lastEditedMillis = currMillis
                if (rapidSucc) {
                    // Normally, if the user edits the same widget multiple times in rapid succession, we fall into
                    // the else case, where we overwrite the history's last state (the previous version of the rapid
                    // succession edit) by the current state. However, if the user round-tripped back to the state
                    // where he started out at the beginning of his rapid succession edits, we remove the rapid
                    // succession state entirely and terminate the rapid succession edit.
                    if (history.size >= 2 && history[currentIdx - 1] == new) {
                        history.removeLast()
                        currentIdx--
                        lastEditedSetting = null
                    } else
                        history[currentIdx] = new
                } else {
                    history.add(new)
                    currentIdx++
                }
                onStylingChange()
            }
        }

        fun undoAndRedraw() {
            if (currentIdx != 0) {
                currentIdx--
                lastEditedSetting = null
                onStylingChange()
                editStylingDialog.panel.setStyling(current)
            }
        }

        fun redoAndRedraw() {
            if (currentIdx != history.lastIndex) {
                currentIdx++
                lastEditedSetting = null
                onStylingChange()
                editStylingDialog.panel.setStyling(current)
            }
        }

        fun resetAndRedraw() {
            if (saved != current) {
                editedAndRedraw(saved, null)
                editStylingDialog.panel.setStyling(saved)
            }
        }

        fun save() {
            writeStyling(stylingFile, current)
            saved = current
            lastEditedSetting = null  // Saving always creates a new undo state.
            projectFrame.panel.editPanel.onStylingSave()
        }

        private fun onStylingChange() {
            projectFrame.panel.editPanel.onStylingChange(
                isUnsaved = current != saved,
                isUndoable = currentIdx != 0,
                isRedoable = currentIdx != history.lastIndex
            )
            tryReadCreditsAndRedraw()
        }

    }

}
