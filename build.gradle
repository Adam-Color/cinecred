plugins {
    id 'org.jetbrains.kotlin.jvm' version '1.4.21'
}

group 'com.loadingbyte'
version '0.1.0-SNAPSHOT'

ext.slf4jVersion = '1.7.30'
ext.batikVersion = '1.13'
ext.javacppVersion = '1.5.4'
ext.ffmpegVersion = '4.3.1-1.5.4'
ext.architectures = ['linux-x86_64', 'macosx-x86_64', 'windows-x86_64']

repositories {
    mavenCentral()
}

dependencies {
    // Logging
    implementation "org.slf4j:slf4j-simple:$slf4jVersion"
    // Batik & PDFBox use JCL; this bridge redirects JCL to slf4j:
    implementation "org.slf4j:jcl-over-slf4j:$slf4jVersion"

    // CSV Parsing
    implementation 'org.apache.commons:commons-csv:1.8'

    // SVG Parsing and Writing
    implementation "org.apache.xmlgraphics:batik-bridge:$batikVersion"
    implementation "org.apache.xmlgraphics:batik-svggen:$batikVersion"
    // For pictures embedded in the SVG:
    implementation "org.apache.xmlgraphics:batik-codec:$batikVersion"

    // PDF Reading and Writing
    implementation 'org.apache.pdfbox:pdfbox:2.0.22'
    implementation 'de.rototor.pdfbox:graphics2d:0.30'

    // Video Encoding
    implementation "org.bytedeco:javacpp:$javacppVersion"
    implementation "org.bytedeco:ffmpeg:$ffmpegVersion"
    architectures.forEach { arch ->
        implementation "org.bytedeco:javacpp:$javacppVersion:$arch"
        implementation "org.bytedeco:ffmpeg:$ffmpegVersion:$arch"
    }

    // UI
    implementation 'com.miglayout:miglayout-swing:5.2'
    implementation 'com.formdev:flatlaf:0.46'
}

configurations.all {
    // Do not let Batik & PDFBox add the commons-logging dependency; instead, we use the slf4j bridge.
    exclude group: 'commons-logging', module: 'commons-logging'
    // The Java XML APIs are part of the JDK itself since Java 5.
    exclude group: 'xml-apis', module: 'xml-apis'
}

compileKotlin.kotlinOptions.jvmTarget = '11'
compileTestKotlin.kotlinOptions.jvmTarget = '11'

// Build fat JAR.
jar {
    manifest.attributes(
            'Main-Class': 'com.loadingbyte.cinecred.MainKt',
            'SplashScreen-Image': 'splash.png'
    )
    from 'LICENSE'
    configurations.runtimeClasspath.forEach { dep ->
        from { dep.isDirectory() ? dep : zipTree(dep) } {
            // Put all licenses and related files into a central 'licenses/' directory and rename
            // them such that each file also carries the name of the JAR it originates from.
            eachFile { details ->
                def filename = details.file.name
                if (filename.contains('LICENSE')) details.path = "licenses/libs/${dep.name}-${filename}"
                else if (filename.contains('NOTICE')) details.path = "licenses/libs/${dep.name}-${filename}"
                else if (filename.contains('README')) details.path = "licenses/libs/${dep.name}-${filename}"
                else if (filename.contains('COPYRIGHT')) details.path = "licenses/libs/${dep.name}-${filename}"
            }
            // Note: The 'license' directory is excluded only if the eachFile instruction has completely emptied it.
            exclude '**/module-info.class', 'checkstyle/**', 'findbugs/**', 'license', 'META-INF/maven/**', 'pmd/**'
        }
    }
}
